import streamlit as st
import os
import numpy as np
import time
import pandas as pd
import threading
from ergonomics import generate_diagnosis
from analise_ergonomica import analisar_metricas_ergonomicas
from yolo_pose_analysis import run_pose_estimation
import plotly.express as px
import plotly.graph_objects as go

st.set_page_config(page_title="ErgoView - An√°lise Ergon√¥mica", layout="wide")

def calculate_angle(a, b, c):
    a, b, c = np.array(a), np.array(b), np.array(c)
    ba = a - b
    bc = c - b
    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc) + 1e-6)
    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
    return np.degrees(angle)

def detectar_desvios_com_persistencia(pose_data, fps=30, persistencia_minima=90):
    desvios_por_tipo = {
        "Inclina√ß√£o excessiva do tronco": [],
        "Bra√ßo elevado acima do ombro": [],
        "Flex√£o profunda do joelho": []
    }

    for i, frame in enumerate(pose_data):
        keypoints = frame["keypoints"]
        try:
            neck = np.mean([keypoints[5], keypoints[6]], axis=0)
            hip = np.mean([keypoints[11], keypoints[12]], axis=0)
            knee = keypoints[13]
            tronco_angle = calculate_angle(neck, hip, knee)
            if tronco_angle < 135:
                desvios_por_tipo["Inclina√ß√£o excessiva do tronco"].append((i, tronco_angle))

            shoulder_left = keypoints[5]
            elbow_left = keypoints[7]
            wrist_left = keypoints[9]
            arm_angle = calculate_angle(shoulder_left, elbow_left, wrist_left)
            if arm_angle > 90:
                desvios_por_tipo["Bra√ßo elevado acima do ombro"].append((i, arm_angle))

            hip_left = keypoints[11]
            knee_left = keypoints[13]
            ankle_left = keypoints[15]
            knee_angle = calculate_angle(hip_left, knee_left, ankle_left)
            if knee_angle < 90:
                desvios_por_tipo["Flex√£o profunda do joelho"].append((i, knee_angle))
        except Exception:
            continue

    desvios_filtrados = []
    for tipo, ocorrencias in desvios_por_tipo.items():
        if not ocorrencias:
            continue
        sequencia = []
        for idx in range(len(ocorrencias)):
            if not sequencia:
                sequencia.append(ocorrencias[idx])
            elif ocorrencias[idx][0] == sequencia[-1][0] + 1:
                sequencia.append(ocorrencias[idx])
            else:
                if len(sequencia) >= persistencia_minima:
                    for frame_idx, angulo in sequencia:
                        tempo_segundos = frame_idx / fps
                        desvios_filtrados.append({
                            "Frame": frame_idx,
                            "Tempo (s)": round(tempo_segundos, 2),
                            "Desvio": tipo,
                            "√Çngulo": round(angulo, 2)
                        })
                sequencia = [ocorrencias[idx]]
        if len(sequencia) >= persistencia_minima:
            for frame_idx, angulo in sequencia:
                tempo_segundos = frame_idx / fps
                desvios_filtrados.append({
                    "Frame": frame_idx,
                    "Tempo (s)": round(tempo_segundos, 2),
                    "Desvio": tipo,
                    "√Çngulo": round(angulo, 2)
                })

    return pd.DataFrame(desvios_filtrados)

def gerar_diagnostico_avancado(metricas, df_desvios):
    diagnostico = []

    # Diagn√≥stico baseado nas m√©tricas
    if metricas["Posturas Inadequadas"] > 0:
        diagnostico.append(f"‚ö†Ô∏è Foram detectadas {metricas['Posturas Inadequadas']} posturas inadequadas, indicando risco ergon√¥mico conforme a NR-17.")
    if metricas["Movimentos Repetitivos"] > 0:
        diagnostico.append("‚ö†Ô∏è Movimentos repetitivos foram identificados, o que pode levar a LER/DORT.")
    if metricas["Posturas For√ßadas (>90s)"] > 0:
        diagnostico.append("‚ö†Ô∏è Posturas for√ßadas foram mantidas por mais de 90 segundos, o que representa risco elevado.")
    if metricas["Pausas/Ritmo de Trabalho"] == 0:
        diagnostico.append("‚ö†Ô∏è Aus√™ncia de pausas detectada. A NR-17 recomenda pausas regulares para recupera√ß√£o.")
    if metricas["√Çngulos Articulares Extremos"] > 0:
        diagnostico.append(f"‚ö†Ô∏è Foram detectados {metricas['√Çngulos Articulares Extremos']} √¢ngulos articulares extremos, o que pode causar sobrecarga muscular.")
    if metricas["Posturas Est√°ticas (>4s)"] > 0:
        diagnostico.append(f"‚ö†Ô∏è {metricas['Posturas Est√°ticas (>4s)']} posturas est√°ticas foram mantidas por mais de 4 segundos.")
    if metricas["Risco Postural"] in ["Moderado", "Alto"]:
        diagnostico.append(f"‚ö†Ô∏è O risco postural geral foi classificado como **{metricas['Risco Postural']}**, indicando necessidade de interven√ß√£o.")

    # Diagn√≥stico baseado nos desvios detectados
    if not df_desvios.empty:
        tipos = df_desvios["Desvio"].value_counts()
        for tipo, qtd in tipos.items():
            diagnostico.append(f"üîç Foram detectadas {qtd} ocorr√™ncias de \"{tipo}\" com persist√™ncia m√≠nima de 3 segundos.")

    if not diagnostico:
        diagnostico.append("‚úÖ Nenhum risco ergon√¥mico relevante foi identificado. A postura est√° dentro dos limites recomendados.")

    return diagnostico


# Interface com abas
st.title("üìä ErgoView - An√°lise Ergon√¥mica com Vis√£o Computacional")
st.markdown("Bem-vindo ao **ErgoView**, uma ferramenta para auxiliar ergonomistas na an√°lise de opera√ß√µes industriais com base em v√≠deo. Software desenvolvido por Eng Di√≥genes Oliveira")

tab1, tab2, tab3, tab4 = st.tabs(["üì• Upload e Processamento", "üìä M√©tricas e Alertas", "üìà Gr√°ficos e Diagn√≥stico", "üìé Relat√≥rios e Downloads"])

with tab1:
    st.header("üì• Upload de V√≠deo")
    video_file = st.file_uploader("Envie um v√≠deo no formato .mp4", type=["mp4"])
    if video_file is not None:
        with open("uploaded_video.mp4", "wb") as f:
            f.write(video_file.read())
        st.video("uploaded_video.mp4")

        timer_placeholder = st.empty()
        progress_bar = st.progress(0.0)
        st.info("üîç Processando v√≠deo... Isso pode levar alguns segundos.")
        start_time = time.time()
        running = True

        def update_timer():
            while running:
                elapsed = time.time() - start_time
                timer_placeholder.markdown(f"‚è±Ô∏è Tempo decorrido: **{elapsed:.1f} segundos**")
                time.sleep(0.1)

        def atualizar_progresso(p):
            progress_bar.progress(min(p, 1.0))

        timer_thread = threading.Thread(target=update_timer)
        timer_thread.start()

        try:
            pose_data, processed_video_path = run_pose_estimation(
                "uploaded_video.mp4",
                progress_callback=atualizar_progresso,
                frame_skip=1,
                save_annotated_video=True
            )
            running = False
            timer_thread.join()
            elapsed_time = time.time() - start_time
            st.success(f"‚úÖ Detec√ß√£o de pose conclu√≠da em {elapsed_time:.2f} segundos.")
            st.session_state.pose_data = pose_data
            st.session_state.processed_video_path = processed_video_path
        except Exception as e:
            running = False
            timer_thread.join()
            st.error(f"Erro ao processar o v√≠deo: {e}")
            st.stop()

with tab2:
    st.header("üìä M√©tricas Ergon√¥micas")
    if "pose_data" in st.session_state:
        pose_data = st.session_state.pose_data
        df_desvios = detectar_desvios_com_persistencia(pose_data, fps=30, persistencia_minima=90)
        metricas = analisar_metricas_ergonomicas(df_desvios)

        col1, col2, col3 = st.columns(3)
        col1.metric("Posturas Inadequadas", metricas["Posturas Inadequadas"], "NR-17")
        col2.metric("Movimentos Repetitivos", metricas["Movimentos Repetitivos"], "NR-17")
        col3.metric("Posturas For√ßadas", metricas["Posturas For√ßadas (>90s)"], "NR-17")

        col4, col5, col6 = st.columns(3)
        col4.metric("Pausas/Ritmo", metricas["Pausas/Ritmo de Trabalho"], "NR-17")
        col5.metric("Mobili√°rio/Layout", metricas["Mobili√°rio/Layout"], "NR-17")
        col6.metric("√Çngulos Extremos", metricas["√Çngulos Articulares Extremos"], "ISO 11226")

        col7, col8, col9 = st.columns(3)
        col7.metric("Posturas Est√°ticas", metricas["Posturas Est√°ticas (>4s)"], "ISO 11226")
        col8.metric("Risco Postural", metricas["Risco Postural"], "ISO 11226")
        col9.metric("Postura Sentada", metricas["Postura Sentada"], "ISO 9241")

        st.markdown("### üìå Descri√ß√µes detalhadas das viola√ß√µes")

        if metricas["Posturas Inadequadas"] > 0:
            st.warning(
                f"üî∏ Foram detectadas {metricas['Posturas Inadequadas']} ocorr√™ncias de posturas inadequadas, como inclina√ß√£o excessiva do tronco, eleva√ß√£o dos bra√ßos acima do ombro ou flex√£o profunda dos joelhos. Essas posturas devem ser evitadas conforme a NR-17.")

        if metricas["Movimentos Repetitivos"] > 0:
            st.warning(
                "üî∏ Foram identificados movimentos repetitivos com os membros superiores, o que pode causar fadiga muscular e les√µes por esfor√ßo repetitivo (LER/DORT), conforme a NR-17.")

        if metricas["Posturas For√ßadas (>90s)"] > 0:
            st.warning(
                "üî∏ Foram detectadas posturas for√ßadas mantidas por mais de 90 segundos, como flex√£o profunda dos joelhos. Isso representa risco ergon√¥mico elevado segundo a NR-17.")

        if metricas["Pausas/Ritmo de Trabalho"] == 0:
            st.warning(
                "üî∏ N√£o foram detectadas pausas significativas durante a atividade. A NR-17 recomenda pausas para recupera√ß√£o f√≠sica e mental.")

        if metricas["√Çngulos Articulares Extremos"] > 0:
            st.warning(
                f"üî∏ Foram identificadas {metricas['√Çngulos Articulares Extremos']} ocorr√™ncias de √¢ngulos articulares extremos (ex: tronco < 90¬∞, bra√ßo > 150¬∞, joelho < 60¬∞), o que representa risco postural segundo a ISO 11226.")

        if metricas["Posturas Est√°ticas (>4s)"] > 0:
            st.warning(
                f"üî∏ Foram detectadas {metricas['Posturas Est√°ticas (>4s)']} posturas est√°ticas mantidas por mais de 4 segundos, o que pode causar fadiga muscular e deve ser evitado conforme a ISO 11226.")

        if metricas["Risco Postural"] in ["Moderado", "Alto"]:
            st.warning(
                f"üî∏ A classifica√ß√£o geral de risco postural foi **{metricas['Risco Postural']}**, indicando necessidade de interven√ß√£o ergon√¥mica segundo a ISO 11226.")

        pose_data = st.session_state.pose_data

with tab3:
    st.header("üìà Gr√°ficos e Diagn√≥stico")
    if "pose_data" in st.session_state:
        pose_data = st.session_state.pose_data
        # Gerar df_angulos a partir de pose_data
        dados = []
        fps = 30
        for i, frame in enumerate(pose_data):
            keypoints = frame["keypoints"]
            try:
                ang_cotovelo = calculate_angle(keypoints[5], keypoints[7], keypoints[9])  # ombro, cotovelo, punho
                ang_joelho = calculate_angle(keypoints[11], keypoints[13], keypoints[15])  # quadril, joelho, tornozelo
                tempo = i / fps
                dados.append({
                    "Tempo (s)": round(tempo, 2),
                    "√Çngulo Cotovelo": round(ang_cotovelo, 2),
                    "√Çngulo Joelho": round(ang_joelho, 2)
                })
            except Exception:
                continue

        df_angulos = pd.DataFrame(dados)
        df_desvios = detectar_desvios_com_persistencia(pose_data, fps=30, persistencia_minima=90)

        # Gr√°fico 1: Evolu√ß√£o dos √Çngulos ao Longo do Tempo
        fig1 = go.Figure()

        # Tra√ßos dos √¢ngulos
        fig1.add_trace(go.Scatter(x=df_angulos["Tempo (s)"], y=df_angulos["√Çngulo Cotovelo"],
                                  mode='lines', name='√Çngulo Cotovelo'))
        fig1.add_trace(go.Scatter(x=df_angulos["Tempo (s)"], y=df_angulos["√Çngulo Joelho"],
                                  mode='lines', name='√Çngulo Joelho'))

        # Linhas horizontais de refer√™ncia para cotovelo
        fig1.add_hline(y=90, line=dict(color="red", dash="dash"),
                       annotation_text="Limite Inferior Cotovelo (90¬∞)", annotation_position="top left")
        fig1.add_hline(y=150, line=dict(color="red", dash="dash"),
                       annotation_text="Limite Superior Cotovelo (150¬∞)", annotation_position="top left")

        # Linhas horizontais de refer√™ncia para joelho
        fig1.add_hline(y=60, line=dict(color="blue", dash="dot"),
                       annotation_text="Limite Inferior Joelho (60¬∞)", annotation_position="bottom left")
        fig1.add_hline(y=90, line=dict(color="blue", dash="dot"),
                       annotation_text="Limite Superior Joelho (90¬∞)", annotation_position="bottom left")

        # Layout
        fig1.update_layout(title="Evolu√ß√£o dos √Çngulos com Limites Ergon√¥micos",
                           xaxis_title="Tempo (s)", yaxis_title="√Çngulo (graus)")

        st.plotly_chart(fig1)

        # Gr√°fico 2: Histograma dos √Çngulos
        fig2 = go.Figure()

        # Histogramas
        fig2.add_trace(go.Histogram(x=df_angulos["√Çngulo Cotovelo"], name="Cotovelo", opacity=0.6))
        fig2.add_trace(go.Histogram(x=df_angulos["√Çngulo Joelho"], name="Joelho", opacity=0.6))

        # Linhas verticais de refer√™ncia
        fig2.add_vline(x=90, line=dict(color="red", dash="dash"), annotation_text="Limite Inferior Cotovelo",
                       annotation_position="top right")
        fig2.add_vline(x=150, line=dict(color="red", dash="dash"), annotation_text="Limite Superior Cotovelo",
                       annotation_position="top right")
        fig2.add_vline(x=60, line=dict(color="blue", dash="dot"), annotation_text="Limite Inferior Joelho",
                       annotation_position="top right")
        fig2.add_vline(x=90, line=dict(color="blue", dash="dot"), annotation_text="Limite Superior Joelho",
                       annotation_position="top right")

        # Layout
        fig2.update_layout(
            barmode='overlay',
            title="Distribui√ß√£o dos √Çngulos Articulares com Limites Ergon√¥micos",
            xaxis_title="√Çngulo (graus)",
            yaxis_title="Frequ√™ncia"
        )

        st.plotly_chart(fig2)

        # Gr√°fico 3: Contagem de Desvios por Tipo
        st.dataframe(df_desvios.head())
        contagem = df_desvios["Desvio"].value_counts().reset_index()
        contagem.columns = ["Desvio", "Contagem"]
        fig3 = px.bar(contagem, x="Desvio", y="Contagem", title="Contagem de Desvios por Tipo")
        st.plotly_chart(fig3)

        # Gr√°fico 4: Dispers√£o de √Çngulo vs Tempo
        fig4 = px.scatter(df_desvios, x="Tempo (s)", y="√Çngulo", color="Desvio",
                          title="Desvios Detectados: √Çngulo vs Tempo")
        st.plotly_chart(fig4)

        st.subheader("üß† Diagn√≥stico Ergon√¥mico")
        diagnosis = gerar_diagnostico_avancado(metricas, df_desvios)
        if diagnosis:
            for item in diagnosis:
                st.write("‚Ä¢", item)
        else:
            st.info("Nenhum alerta ergon√¥mico detectado.")


with tab4:
    st.header("üìé Relat√≥rios e Downloads")
    if "pose_data" in st.session_state:
        pose_data = st.session_state.pose_data
        df_desvios = detectar_desvios_com_persistencia(pose_data, fps=30, persistencia_minima=90)

        if not df_desvios.empty:
            st.dataframe(df_desvios)
            csv = df_desvios.to_csv(index=False).encode("utf-8")
            st.download_button("üì• Baixar CSV dos Desvios", data=csv, file_name="desvios_nr17.csv", mime="text/csv")
        else:
            st.info("Nenhum desvio postural detectado conforme NR-17.")

        if "processed_video_path" in st.session_state and os.path.exists(st.session_state.processed_video_path):
            with open(st.session_state.processed_video_path, "rb") as f:
                st.download_button(
                    label="üì• Baixar v√≠deo com esqueleto",
                    data=f,
                    file_name="video_esqueleto.mp4",
                    mime="video/mp4"
                )
